% \section{Evaluation of the config Noc}
% \section{Introduction}
The config NoC is mainly used for configuration writes to the neuron core memories.
Another use is status monitoring reads while the GrAICore is in operation.
The config NoC is a separate NoC next to the event NoC, which is used for the execution of a model.
It connects all 144 neuron cores via a 2D mesh topology (see \cref{fig:noc}).
The network receives and forwards data using routers at each neuron core.
The config NoC has a single 16-bit wide interface for incoming data from an AXI slave.
Similarly, the links between every two adjacent routers are 16-bit wide. 
The clock frequency of the system is \SI{800}{MHz}.


\section{Architecture}
\lipsum[1]
% purpose
% topology
% 
The config NoC makes u
The config NoC incorporates a 2D 
Unlike the event NoC, the config NoC incorporates a 2D mesh topology.
The wraparound links of the event NoC provide noticeable benefits in communication performance.
In the event NoC, intercommunication happens between the neuron cores.
The presence of the wraparound links helps to drastically reduce the average amount of hops a packet has to take.
T
The wraparound links do not provide any noticeable benefits to the config NoC since these interactions do not occur with the config NoC.


\section{Network packet format}
The network makes use of network packets for data communication.
The phit size of the config NoC is 16 bits wide.
This implies that a total of 16 bits of data can be transferred over a link in a single cycle.
Each packet contains a header, made up of two separate phits.
The header contains the fields as shown in \cref{tab:header_fields}.

\begin{table}[hbtp]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Header field} & \textbf{\# of bits} \\ \midrule
Packet type           & 2                   \\
Destination cluster X & 4                   \\
Destination cluster Y & 4                   \\
Address               & 20                  \\ \bottomrule
\end{tabular}
\caption{Header fields of a config NoC packet}
\label{tab:header_fields}
\end{table}

The \textit{packet type} field defines whether the packet is a \textit{read request}, \textit{read response} or \textit{write request} packet.
A \textit{read request} packet is initiated by the host.
It is used to retrieve data from a neuron core.
A \textit{read response} packet is produced as an answer to a \textit{read request}.
This packet contains the requested data that is sent back to the host.
Finally, the \textit{write request} is used to write data to a neuron core.

Both the \textit{read response} and \textit{write request} packets has two phits following the header (see \cref{fig:read_response_packet,fig:write_request_packet}).
These two phits contain the payload data that is requested.
Thus in total, packets of these two types are 64 bits in size.
The \textit{read request} packet only consists of the header (see \cref{fig:read_request_packet}).

The destination cluster coordinates are both 4 bits in size due to the need to address 12 different X and 12 different Y coordinates.

The \textit{address field} of 20 bits, allows the system to address $2^{20}$ different addresses.
This address space is used to address the SRAM and the register bank of a neuron core.
% This address space is used to address the SRAM and the register bank of a neuron core, with room to spare \cite{TODO}.

With this packet format, we observe that there is a significant overhead when writing or reading data.
For every 32 bits of data we read or write, an overhead of 32 bits is also included.
In other words, there is an overhead of $100\%$ for every read or write request of 32 bits.
At most, on average, the network transmits one byte of payload data per cycle.

% There is potential to increase this to 64 bits (or 8 bytes) per cycle which is the amount of data an SRAM in a single core can write in a single cycle.

\hspace*{0.5em}
\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{\linewidth}
        \centering
        \begin{adjustbox}{width=0.8\linewidth}
            \input{assets/packet_format/read_request_packet}
        \end{adjustbox}
        \caption{Read request}
        \label{fig:read_request_packet}
    \end{subfigure}
    \\ \vspace{1.5em}
    \begin{subfigure}[b]{\linewidth}
        \centering
        \begin{adjustbox}{width=0.8\linewidth}
            \input{assets/packet_format/read_response_packet}
        \end{adjustbox}
        \caption{Read response}
        \label{fig:read_response_packet}
    \end{subfigure}
    \\ \vspace{1.5em}
    \begin{subfigure}[b]{\linewidth}
        \centering
        \begin{adjustbox}{width=0.8\linewidth}
            \input{assets/packet_format/write_request_packet}
        \end{adjustbox}
        \caption{Write request}
        \label{fig:write_request_packet}
    \end{subfigure}
    \caption{
        Config NoC packet structures
    }
    \label{fig:config_noc_packets}
\end{figure}

\section{Bandwidth}
Configuration is done by transferring write request packets from the host to one or more neuron cores.
A write request packet consists of 64 bits in total.
Recall that the SRAM capacity of a single neuron core is \SI{256}{KiB}.
If we want to completely fill up one of these memories, a total of $\frac{\SI{256}{KiB}}{\SI{32}{b}} = 65536$ write request packets needs to be sent.
This means that, in total, \SI{256}{KiB} of payload data and \SI{256}{KiB} of header data is sent through the NoC.

To estimate the time to write a certain amount of data to the memories of the GrAICore, we can make use of \cref{eq:latency}.
The effective bandwidth can be calculated with \cref{eq:bandwidth}.

\begin{equation}
    T = 
    \frac{d_{\text{payload}} + d_{\text{overhead}}}
    {f_{\text{clock}} \times w_{\text{phit}}}
\label{eq:latency}
\end{equation}

\begin{equation}
    \text{BW}_{\text{eff}} =
    \frac{d_\text{payload}}{T}
\label{eq:bandwidth}
\end{equation}

\begin{eqexpl}[15mm]
    \item{$T$} time to write data
    \item{$\text{BW}_{\text{eff}}$} effective bandwidth
    \item{$d_{\text{payload}}$} amount of payload data
    \item{$d_{\text{overhead}}$} amount of overhead data
    \item{$f_{\text{clock}}$} system's clock frequency
    \item{$w_{\text{phit}}$} width of a phit
\end{eqexpl}

For example, to completely fill up the GrAICore's memory (\SI{36}{MiB}), it will take around \SI{47}{ms}\footnote{$\frac{\SI{36}{MiB} + \SI{36}{MiB}}{\SI{800}{MHz} \times \SI{16}{b}}$}.
% This translates to an effective bandwidth of $\frac{\SI{36}{MiB}}{\SI{47}{ms}} \approx \SI{763}{MiB/s}$.
This translates to an effective bandwidth of \SI{763}{MiB/s}\footnote{$\frac{\SI{36}{MiB}}{\SI{47}{ms}}$}.
Here we assumed that no delays are introduced by software and reading the data from storage.
Furthermore, it is good to note that the delays introduced by hops are minimal due to pipelining.
Thus, \cref{eq:bandwidth} provides us the config NoC's \textit{peak} effective bandwidth.